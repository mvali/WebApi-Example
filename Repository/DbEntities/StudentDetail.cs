using Repository.DbConfig;
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;

namespace Repository.DbEntities
{
    // All in One Comamnds, queries, LINQ (classes should be separated in files but for usability purpose it will work)
    public class StudentDetail
    {
        // dotnet tool install --global dotnet-ef  // or see below to update in case version used is older then the one installed as nuget package
        // dotnet tool update --global dotnet-ef
        // dotnet ef dbcontext scaffold "Data Source=AMDP\SQLEXPRESS2019;Initial Catalog=WebApiExample;User ID=webapi;Password=webapi;" Microsoft.EntityFrameworkCore.SqlServer -o MigrationDbFirst --project Repository
        //      // -o MigrationDbFirst  "-o" is to set as option folder "MigrationDbFirst" as root for tables from Db to be set as classes
        //      // --project Repository  to set the project where migration is applied (in case project is not set as startup project)
        //      // -c "DbContextApi" // default: DbContext, new:DbContextApi
        //      // The configurations are placed in the generated context's OnModelCreating method. To use Data Annotations for configuration, you can use the -d or --data-annotations
        // dotnet ef dbcontext scaffold "Data Source=AMDP\SQLEXPRESS2019;Initial Catalog=WebApiExample;User ID=webapi;Password=webapi;" Microsoft.EntityFrameworkCore.SqlServer -o MigrationDbFirst --project Repository --force
        //      // -f or --force option to update the Model based on Db changes
        // dotnet ef dbcontext scaffold "Data Source=AMDP\SQLEXPRESS2019;Initial Catalog=WebApiExample;User ID=webapi;Password=webapi;" Microsoft.EntityFrameworkCore.SqlServer -o ModelDbFirst -c "DbContextApi" -d --project Repository --force

        // FromSql is obsolete -> use FromSqlRaw ... see below

        private readonly SqlContext _context; // autogenerated: press "."  on _context: .generate readonly field

        public int Id { get; set; }
        public string Name { get; set; }
        public Gender Gender { get; set; }
        public string RollNumber { get; set; }
        public StudentStatus Status { get; set; }
        public StudentType Type { get; set; }
        public string FatherName { get; set; }
        public string FatherContact { get; set; }
        public string SchoolClass { get; set; }
        public string Section { get; set; }
        public int SsId { get; set; }
        public int SectionId { get; set; }
        public int EnrollmentId { get; set; }

        public StudentDetail(SqlContext context)
        {
            _context = context;
        }

        /*
        SqlParameter usernameParam = new SqlParameter("@username", usernameVal ?? (object)DBNull.Value);
        SqlParameter passwordParam = new SqlParameter("@password", passwordVal ?? (object)DBNull.Value);

        string sqlQuery = "EXEC [dbo].[LoginByUsernamePassword] @username, @password";

        // context is DbContext instance
        lst = await context.Query<Authenticate>().FromSql(sqlQuery, usernameParam,passwordParam).ToListAsync();   // FromSql does not compile
        lst = await context.Set<Authenticate>().FromSqlRaw(sqlQuery, usernameParam,passwordParam).ToListAsync();    // Query<T>() old->new Set<T>().
        //  FromSqlInterpolated use to avoid SqlInjections
        //  FromSqlInterpolated can only be used on query roots
        //  FromSqlRaw can only be used on query roots, that is directly on the DbSet<>
        */
        public IEnumerable<StudentDetail> GetStudentDetails(int ssid)
        {
            var ssidParam = new SqlParameter("@ssid", ssid);
            var result = _context.Set<StudentDetail>().FromSqlRaw("exec GetStudentDetail @ssid", ssidParam).AsNoTracking().ToList();
            _context.Database.ExecuteSqlRaw("Aliments_Get_byId {0}", ssid.ToString());

            _context.Database.ExecuteSqlRaw(
                "Aliments_Get_byId @p0",
                parameters: new[] { ssid.ToString() });

            var user2a = "johndoe";
            var blogs2a = _context.Aliments
                .FromSqlInterpolated($"EXECUTE dbo.GetMostPopularBlogsForUser {user2a}")
                .ToList();

            var rowsAffected = _context.Database.ExecuteSqlInterpolated($"UpdateProfilesCountry {ssid}");

            var user1a = "johndoe";
            var blogs1a = _context.Aliments
                .FromSqlRaw("EXECUTE dbo.GetMostPopularBlogsForUser {0}", user1a)
                .ToList();

            var user1 = new SqlParameter("user", "johndoe");
            var user2 = new SqlParameter("user", "johndoe");
            var blogs = _context.Aliments
                .FromSqlRaw("EXECUTE dbo.GetMostPopularBlogsForUser @user1 @user2", user1, user2)
                .ToList();
            var blogs5 = _context.Aliments      // named parameters in the SQL query string,
                .FromSqlRaw("EXECUTE dbo.GetMostPopularBlogsForUser @filterByUser=@user", user1, user2)
                .ToList();

            // Composing with LINQ
            var searchTerm = ".Net";
            var blogs4 = _context.Aliments
                .FromSqlInterpolated($"SELECT * FROM dbo.SearchBlogs({searchTerm})")
                .Include(b => b.Platform)
                .Where(b => b.Id > 3)
                .OrderByDescending(b => b.Name)
                .ToList();



            var query = from b in _context.Set<Blog>()
                        from p in _context.Set<Post>().Where(p => b.BlogId == p.BlogId) // INNER Join
                        select new { b, p };

            var query2 = from b in _context.Set<Blog>()
                         from p in _context.Set<Post>().Where(p => b.BlogId == p.BlogId).DefaultIfEmpty()   // LEFT Join (DefaultIfEmpty)
                         select new { b, p };
            var query3 = from b in _context.Set<Blog>()
                         from p in _context.Set<Post>().Select(p => b.Url + "=>" + p.Title) // ([b].[Url] + N'=>') + [p].[Title] AS [p]
                         select new { b, p };

            var query4 = from p in _context.Set<Post>()
                        group p by p.AuthorId       // GROUP BY [p].[AuthorId]
                        into g
                        where g.Count() > 0         // HAVING COUNT(*) > 0
                        orderby g.Key
                        select new { g.Key, Count = g.Count() };

            var query5 = from b in _context.Set<Blog>()
                         join p in _context.Set<Post>()
                             on b.BlogId equals p.BlogId into grouping
                        from p in grouping.DefaultIfEmpty()
                        select new { b, p };

            return result;
        }
        /*partial void OnModelCreatingPartial(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<TopCustomerId>().HasNoKey();
        }*/
    }

    internal class Post
    {
        public int PostId { get; set; }
        public int BlogId { get; set; }
        public int AuthorId { get; set; }
        public string Title { get; set; }
        public string Content{ get; set; }
    }

    internal class Blog
    {
        public int BlogId { get; set; }
        public int OwnerId { get; set; }
        public int Rating { get; set; }
        public string Url { get; set; }
    }

    public class StudentType
    {
        public int Id { get; set; }
    }

    public class StudentStatus
    {
        public int Id { get; set; }
    }

    public class Gender
    {
        public int Id { get; set; }
    }
}
